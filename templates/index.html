<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>netdash // network monitor</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Consolas', 'Fira Code', 'Source Code Pro', 'JetBrains Mono', monospace;
            background: #0a0a0a;
            color: #b0b0b0;
            min-height: 100vh;
            font-size: 13px;
            line-height: 1.5;
        }
        header {
            background: #111111;
            padding: 0.8rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #222;
        }
        header h1 {
            font-size: 1.1rem; color: #00cc66; font-weight: 500;
            letter-spacing: 2px; text-transform: uppercase;
        }
        header h1::before { content: "> "; color: #555; }
        .summary { display: flex; gap: 2rem; align-items: center; }
        .stat { text-align: center; }
        .stat .value { font-size: 1.4rem; font-weight: bold; color: #00cc66; }
        .stat .label {
            font-size: 0.65rem; color: #555; text-transform: uppercase;
            letter-spacing: 1.5px;
        }
        .scan-btn {
            background: transparent; color: #00cc66; border: 1px solid #00cc66;
            padding: 0.4rem 1.2rem; border-radius: 2px; cursor: pointer;
            font-family: inherit; font-size: 0.8rem; text-transform: uppercase;
            letter-spacing: 1px; transition: all 0.15s;
        }
        .scan-btn:hover { background: #00cc66; color: #0a0a0a; }
        .scan-btn:disabled { border-color: #333; color: #333; background: transparent; cursor: not-allowed; }

        /* Tabs */
        .tabs {
            display: flex; background: #0e0e0e;
            border-bottom: 1px solid #222;
            padding: 0 2rem;
        }
        .tab {
            padding: 0.6rem 1.5rem; cursor: pointer;
            color: #555; font-size: 0.8rem; border-bottom: 1px solid transparent;
            margin-bottom: -1px; transition: all 0.15s; user-select: none;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .tab:hover { color: #888; }
        .tab.active { color: #00cc66; border-bottom-color: #00cc66; }
        .tab-content { display: none; padding: 1.5rem 2rem; }
        .tab-content.active { display: block; }

        .scanning-bar {
            background: #111; padding: 0.5rem 1rem; border-radius: 2px;
            margin-bottom: 1rem; display: none; animation: pulse 1.5s infinite;
            border-left: 2px solid #cc8800; color: #cc8800; font-size: 0.8rem;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }

        /* Device table */
        table {
            width: 100%; border-collapse: collapse;
            background: transparent;
        }
        th, td {
            padding: 0.5rem 1rem; text-align: left;
            border-bottom: 1px solid #1a1a1a;
        }
        th {
            background: #0e0e0e; cursor: pointer; user-select: none;
            white-space: nowrap; font-size: 0.7rem; color: #555;
            text-transform: uppercase; letter-spacing: 1.5px;
            font-weight: 500; border-bottom: 1px solid #222;
        }
        th:hover { color: #888; }
        th .arrow { margin-left: 4px; font-size: 0.6rem; color: #00cc66; }
        tr:hover td { background: #111; }
        .status-dot {
            display: inline-block; width: 6px; height: 6px;
            border-radius: 50%; margin-right: 8px; vertical-align: middle;
        }
        .status-online { background: #00cc66; box-shadow: 0 0 4px #00cc6666; }
        .status-offline { background: #cc3333; box-shadow: 0 0 4px #cc333366; }
        .empty-msg { text-align: center; padding: 3rem; color: #333; }

        /* Port badge & button */
        .port-badge {
            background: transparent; color: #00cc66; padding: 1px 6px;
            border: 1px solid #1a3a1a; border-radius: 2px;
            font-size: 0.75rem; cursor: pointer; font-family: inherit;
        }
        .port-badge:hover { border-color: #00cc66; }
        .port-scan-btn {
            background: transparent; border: 1px solid #222; color: #444;
            padding: 1px 6px; border-radius: 2px; font-size: 0.7rem;
            cursor: pointer; font-family: inherit; text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .port-scan-btn:hover { border-color: #00cc66; color: #00cc66; }
        .port-scanning { color: #cc8800; font-size: 0.75rem; }

        /* Modal */
        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0;
            width: 100%; height: 100%; background: rgba(0,0,0,0.85);
            z-index: 1000; justify-content: center; align-items: center;
        }
        .modal-overlay.show { display: flex; }
        .modal {
            background: #111; border-radius: 2px; padding: 1.5rem;
            max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;
            border: 1px solid #222;
        }
        .modal h2 { color: #00cc66; margin-bottom: 1rem; font-size: 0.95rem; font-weight: 500; }
        .modal table { font-size: 0.8rem; }
        .modal-close {
            float: right; background: none; border: none;
            color: #444; font-size: 1.2rem; cursor: pointer; font-family: inherit;
        }
        .modal-close:hover { color: #cc3333; }

        /* Bandwidth */
        .bw-current {
            display: flex; gap: 4rem; margin-bottom: 1.5rem;
            justify-content: center;
        }
        .bw-stat { text-align: center; }
        .bw-stat .bw-value { font-size: 1.8rem; font-weight: bold; }
        .bw-stat .bw-label {
            font-size: 0.65rem; color: #444; text-transform: uppercase;
            letter-spacing: 2px;
        }
        .bw-rx .bw-value { color: #00cc66; }
        .bw-tx .bw-value { color: #0088cc; }
        .time-btns { display: flex; gap: 0.5rem; margin-bottom: 1rem; justify-content: center; }
        .time-btn {
            background: transparent; color: #444; border: 1px solid #222;
            padding: 0.3rem 1rem; border-radius: 2px; cursor: pointer;
            font-family: inherit; font-size: 0.75rem;
        }
        .time-btn:hover { border-color: #555; color: #888; }
        .time-btn.active { border-color: #00cc66; color: #00cc66; }
        #bw-chart-container { background: #0e0e0e; border-radius: 2px; padding: 1rem; border: 1px solid #1a1a1a; }

        /* Network graph */
        #network-graph {
            width: 100%; height: 500px; background: #0e0e0e;
            border-radius: 2px; border: 1px solid #1a1a1a;
        }

        /* History timeline */
        .history-controls {
            margin-bottom: 1.5rem; display: flex; gap: 1rem; align-items: center;
            font-size: 0.8rem; color: #555;
        }
        .history-controls select {
            background: #111; color: #b0b0b0; border: 1px solid #222;
            padding: 0.4rem 0.8rem; border-radius: 2px; font-family: inherit;
            font-size: 0.8rem;
        }
        .timeline { position: relative; padding-left: 30px; }
        .timeline::before {
            content: ''; position: absolute; left: 10px; top: 0;
            bottom: 0; width: 1px; background: #1a1a1a;
        }
        .timeline-item {
            position: relative; margin-bottom: 0.8rem;
            padding: 0.6rem 1rem; background: #0e0e0e;
            border-radius: 2px; border: 1px solid #1a1a1a;
        }
        .timeline-item::before {
            content: ''; position: absolute; left: -24px; top: 0.9rem;
            width: 7px; height: 7px; border-radius: 50%;
        }
        .timeline-item.connected::before { background: #00cc66; box-shadow: 0 0 4px #00cc6666; }
        .timeline-item.disconnected::before { background: #cc3333; box-shadow: 0 0 4px #cc333366; }
        .timeline-item .ev-time { color: #444; font-size: 0.75rem; }
        .timeline-item .ev-desc { margin-top: 0.2rem; font-size: 0.85rem; }
        .timeline-item .ev-ip { color: #00cc66; }
        .load-more-btn {
            display: block; margin: 1rem auto; background: transparent;
            color: #555; border: 1px solid #222; padding: 0.4rem 2rem;
            border-radius: 2px; cursor: pointer; font-family: inherit;
            font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px;
        }
        .load-more-btn:hover { border-color: #555; color: #888; }

        /* Latency */
        .lat-section-label {
            font-size: 0.7rem; color: #444; text-transform: uppercase;
            letter-spacing: 2px; margin: 1.5rem 0 0.8rem; padding-bottom: 0.3rem;
            border-bottom: 1px solid #1a1a1a;
        }
        .lat-section-label:first-child { margin-top: 0; }
        .inet-health { display: flex; gap: 1.5rem; margin-bottom: 1rem; }
        .inet-box {
            flex: 1; background: #0e0e0e; border: 1px solid #1a1a1a;
            border-radius: 2px; padding: 1rem; text-align: center; position: relative;
        }
        .inet-indicator {
            width: 8px; height: 8px; border-radius: 50%; position: absolute;
            top: 0.8rem; right: 0.8rem; background: #333;
        }
        .inet-indicator.good { background: #00cc66; box-shadow: 0 0 6px #00cc6644; }
        .inet-indicator.warn { background: #cc8800; box-shadow: 0 0 6px #cc880044; }
        .inet-indicator.bad { background: #cc3333; box-shadow: 0 0 6px #cc333344; }
        .inet-label { font-size: 0.8rem; color: #888; margin-bottom: 0.2rem; }
        .inet-ip { font-size: 0.7rem; color: #444; margin-bottom: 0.5rem; }
        .inet-rtt { font-size: 1.6rem; font-weight: bold; color: #00cc66; }
        .inet-rtt.warn { color: #cc8800; }
        .inet-rtt.bad { color: #cc3333; }
        .inet-loss { font-size: 0.7rem; color: #444; margin-top: 0.3rem; }
        .inet-loss.has-loss { color: #cc3333; }
        .lat-table { margin-bottom: 1rem; }
        .lat-table tbody tr { cursor: pointer; }
        .lat-table tbody tr:hover td { background: #151515; }
        .lat-table tbody tr.selected td { background: #0a1a0a; border-color: #1a3a1a; }
        .lat-rtt-good { color: #00cc66; }
        .lat-rtt-warn { color: #cc8800; }
        .lat-rtt-bad { color: #cc3333; }
        .lat-sparkline { display: inline-flex; align-items: end; gap: 1px; height: 18px; }
        .lat-sparkline .lat-spark-bar {
            width: 3px; background: #00cc66; border-radius: 1px 1px 0 0; min-height: 1px;
        }
        .lat-sparkline .lat-spark-bar.loss { background: #cc3333; }
        .lat-detail-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 0.8rem;
        }
        #lat-detail-ip { font-size: 0.85rem; color: #555; }
        #lat-chart-container {
            background: #0e0e0e; border-radius: 2px; padding: 1rem;
            border: 1px solid #1a1a1a;
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0a0a0a; }
        ::-webkit-scrollbar-thumb { background: #222; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #333; }

        @media (max-width: 768px) {
            header { flex-direction: column; gap: 0.8rem; }
            .tabs { padding: 0 1rem; overflow-x: auto; }
            .tab { padding: 0.5rem 1rem; font-size: 0.7rem; white-space: nowrap; }
            .tab-content { padding: 1rem; }
            th, td { padding: 0.4rem 0.5rem; font-size: 0.8rem; }
        }
    </style>
</head>
<body>
    <header>
        <h1>netdash</h1>
        <div class="summary">
            <div class="stat">
                <div class="value" id="total-count">0</div>
                <div class="label">Total</div>
            </div>
            <div class="stat">
                <div class="value" id="online-count">0</div>
                <div class="label">Online</div>
            </div>
            <div class="stat">
                <div class="value" id="offline-count">0</div>
                <div class="label">Offline</div>
            </div>
            <button class="scan-btn" id="scan-btn" onclick="triggerScan()">scan</button>
        </div>
    </header>

    <div class="tabs">
        <div class="tab active" data-tab="devices">devices</div>
        <div class="tab" data-tab="netmap">topology</div>
        <div class="tab" data-tab="bandwidth">bandwidth</div>
        <div class="tab" data-tab="latency">latency</div>
        <div class="tab" data-tab="history">events</div>
    </div>

    <!-- Devices Tab -->
    <div class="tab-content active" id="tab-devices">
        <div class="scanning-bar" id="scanning-bar">scanning network...</div>
        <table>
            <thead>
                <tr>
                    <th data-col="status" data-type="string">Status <span class="arrow"></span></th>
                    <th data-col="ip" data-type="ip">IP Address <span class="arrow"></span></th>
                    <th data-col="hostname" data-type="string">Hostname <span class="arrow"></span></th>
                    <th data-col="mac" data-type="string">MAC <span class="arrow"></span></th>
                    <th data-col="vendor" data-type="string">Vendor <span class="arrow"></span></th>
                    <th data-col="last_seen" data-type="string">Last Seen <span class="arrow"></span></th>
                    <th>Ports</th>
                </tr>
            </thead>
            <tbody id="device-table"></tbody>
        </table>
        <div class="empty-msg" id="empty-msg">awaiting initial scan...</div>
    </div>

    <!-- Network Map Tab -->
    <div class="tab-content" id="tab-netmap">
        <div id="network-graph"></div>
    </div>

    <!-- Bandwidth Tab -->
    <div class="tab-content" id="tab-bandwidth">
        <div class="bw-current">
            <div class="bw-stat bw-rx">
                <div class="bw-value" id="bw-rx-val">--</div>
                <div class="bw-label">rx (down)</div>
            </div>
            <div class="bw-stat bw-tx">
                <div class="bw-value" id="bw-tx-val">--</div>
                <div class="bw-label">tx (up)</div>
            </div>
        </div>
        <div class="time-btns">
            <button class="time-btn" data-minutes="5">5m</button>
            <button class="time-btn" data-minutes="15">15m</button>
            <button class="time-btn active" data-minutes="60">1h</button>
            <button class="time-btn" data-minutes="1440">24h</button>
        </div>
        <div id="bw-chart-container">
            <canvas id="bw-chart"></canvas>
        </div>
    </div>

    <!-- Latency Tab -->
    <div class="tab-content" id="tab-latency">
        <div class="lat-section-label">internet health</div>
        <div class="inet-health">
            <div class="inet-box" id="inet-1.1.1.1">
                <div class="inet-indicator"></div>
                <div class="inet-label">Cloudflare</div>
                <div class="inet-ip">1.1.1.1</div>
                <div class="inet-rtt">--</div>
                <div class="inet-loss">0% loss</div>
            </div>
            <div class="inet-box" id="inet-8.8.8.8">
                <div class="inet-indicator"></div>
                <div class="inet-label">Google DNS</div>
                <div class="inet-ip">8.8.8.8</div>
                <div class="inet-rtt">--</div>
                <div class="inet-loss">0% loss</div>
            </div>
            <div class="inet-box" id="inet-1.0.0.1">
                <div class="inet-indicator"></div>
                <div class="inet-label">Cloudflare 2</div>
                <div class="inet-ip">1.0.0.1</div>
                <div class="inet-rtt">--</div>
                <div class="inet-loss">0% loss</div>
            </div>
        </div>

        <div class="lat-section-label">device latency</div>
        <table class="lat-table">
            <thead>
                <tr>
                    <th data-latcol="ip" data-type="ip">IP Address <span class="arrow"></span></th>
                    <th data-latcol="hostname" data-type="string">Hostname <span class="arrow"></span></th>
                    <th data-latcol="latest_rtt" data-type="number">RTT (ms) <span class="arrow"></span></th>
                    <th data-latcol="loss_pct" data-type="number">Loss % <span class="arrow"></span></th>
                    <th>Trend</th>
                </tr>
            </thead>
            <tbody id="lat-device-table"></tbody>
        </table>

        <div class="lat-section-label">latency detail</div>
        <div class="lat-detail-header">
            <span id="lat-detail-ip">select a device above</span>
            <div class="time-btns lat-time-btns">
                <button class="time-btn lat-time-btn" data-latmin="5">5m</button>
                <button class="time-btn lat-time-btn" data-latmin="15">15m</button>
                <button class="time-btn lat-time-btn active" data-latmin="60">1h</button>
                <button class="time-btn lat-time-btn" data-latmin="1440">24h</button>
            </div>
        </div>
        <div id="lat-chart-container">
            <canvas id="lat-chart"></canvas>
        </div>
    </div>

    <!-- History Tab -->
    <div class="tab-content" id="tab-history">
        <div class="history-controls">
            <label>Filter by device:</label>
            <select id="history-filter">
                <option value="">All devices</option>
            </select>
        </div>
        <div class="timeline" id="timeline"></div>
        <button class="load-more-btn" id="load-more-btn" onclick="loadMoreHistory()">load more</button>
    </div>

    <!-- Port Details Modal -->
    <div class="modal-overlay" id="port-modal">
        <div class="modal">
            <button class="modal-close" onclick="closePortModal()">&times;</button>
            <h2 id="modal-title">Port Details</h2>
            <div id="modal-body"></div>
        </div>
    </div>

    <script>
    // --- State ---
    let currentDevices = [];
    let sortCol = "ip";
    let sortAsc = true;
    let bwChart = null;
    let bwMinutes = 60;
    let bwInterval = null;
    let graphNetwork = null;
    let graphInterval = null;
    let graphInitialized = false;
    let chartInitialized = false;
    let historyOffset = 0;
    const HISTORY_LIMIT = 50;

    // --- Tabs ---
    document.querySelectorAll(".tab").forEach(tab => {
        tab.addEventListener("click", () => {
            document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
            document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
            tab.classList.add("active");
            document.getElementById("tab-" + tab.dataset.tab).classList.add("active");

            if (tab.dataset.tab === "netmap") initGraph();
            if (tab.dataset.tab === "bandwidth") initBandwidth();
            if (tab.dataset.tab === "latency") initLatency();
            if (tab.dataset.tab === "history") { historyOffset = 0; loadHistory(true); }
        });
    });

    // --- Utilities ---
    function compareIP(a, b) {
        const pa = a.split(".").map(Number);
        const pb = b.split(".").map(Number);
        for (let i = 0; i < 4; i++) {
            if (pa[i] !== pb[i]) return pa[i] - pb[i];
        }
        return 0;
    }

    function sortDevices(devices) {
        return [...devices].sort((a, b) => {
            let va = a[sortCol] || "";
            let vb = b[sortCol] || "";
            let cmp = sortCol === "ip" ? compareIP(va, vb) : va.localeCompare(vb);
            return sortAsc ? cmp : -cmp;
        });
    }

    function formatTime(iso) {
        if (!iso) return "";
        return new Date(iso).toLocaleString();
    }

    function formatBytes(bytes) {
        if (bytes == null || isNaN(bytes)) return "--";
        if (bytes < 1024) return bytes.toFixed(0) + " B/s";
        if (bytes < 1048576) return (bytes / 1024).toFixed(1) + " KB/s";
        return (bytes / 1048576).toFixed(2) + " MB/s";
    }

    function escapeHtml(s) {
        const div = document.createElement("div");
        div.textContent = s;
        return div.innerHTML;
    }

    // --- Device Table ---
    function renderDevices() {
        const tbody = document.getElementById("device-table");
        const sorted = sortDevices(currentDevices);
        const online = currentDevices.filter(d => d.status === "online").length;

        document.getElementById("total-count").textContent = currentDevices.length;
        document.getElementById("online-count").textContent = online;
        document.getElementById("offline-count").textContent = currentDevices.length - online;
        document.getElementById("empty-msg").style.display = currentDevices.length ? "none" : "block";

        tbody.innerHTML = sorted.map(d => {
            let portCell;
            const ports = d.ports || [];
            const openPorts = ports.filter(p => p.state === "open");
            if (openPorts.length > 0) {
                portCell = `<span class="port-badge" onclick="showPorts('${escapeHtml(d.ip)}')">${openPorts.length} open</span>`;
            } else if (ports.length > 0) {
                portCell = `<span class="port-badge" onclick="showPorts('${escapeHtml(d.ip)}')">0 open</span>`;
            } else {
                portCell = `<button class="port-scan-btn" onclick="startPortScan('${escapeHtml(d.ip)}')">Scan</button>`;
            }
            return `<tr>
                <td><span class="status-dot status-${d.status}"></span>${d.status}</td>
                <td>${escapeHtml(d.ip)}</td>
                <td>${escapeHtml(d.hostname || "-")}</td>
                <td>${escapeHtml(d.mac || "-")}</td>
                <td>${escapeHtml(d.vendor || "-")}</td>
                <td>${formatTime(d.last_seen)}</td>
                <td>${portCell}</td>
            </tr>`;
        }).join("");

        document.querySelectorAll("#tab-devices th[data-col]").forEach(th => {
            const arrow = th.querySelector(".arrow");
            arrow.textContent = th.dataset.col === sortCol ? (sortAsc ? "\u25B2" : "\u25BC") : "";
        });
    }

    document.querySelectorAll("#tab-devices th[data-col]").forEach(th => {
        th.addEventListener("click", () => {
            if (sortCol === th.dataset.col) { sortAsc = !sortAsc; }
            else { sortCol = th.dataset.col; sortAsc = true; }
            renderDevices();
        });
    });

    async function fetchDevices() {
        try {
            const resp = await fetch("/api/devices");
            const data = await resp.json();
            currentDevices = data.devices;
            document.getElementById("scanning-bar").style.display = data.scanning ? "block" : "none";
            renderDevices();
        } catch (e) { console.error("Fetch error:", e); }
    }

    async function triggerScan() {
        const btn = document.getElementById("scan-btn");
        btn.disabled = true;
        try { await fetch("/api/scan", { method: "POST" }); }
        catch (e) { console.error("Scan trigger error:", e); }
        setTimeout(() => { btn.disabled = false; }, 3000);
    }

    // --- Port Scanning ---
    async function startPortScan(ip) {
        try {
            const resp = await fetch(`/api/portscan/${ip}`, { method: "POST" });
            if (resp.status === 409) {
                alert("Another port scan is already running. Please wait.");
                return;
            }
            // Replace button with scanning indicator
            renderDevices();
            pollPortScan(ip);
        } catch (e) { console.error("Port scan error:", e); }
    }

    function pollPortScan(ip) {
        const poll = setInterval(async () => {
            try {
                const resp = await fetch(`/api/portscan/${ip}`);
                const data = await resp.json();
                if (!data.scanning) {
                    clearInterval(poll);
                    // Update local device data
                    const dev = currentDevices.find(d => d.ip === ip);
                    if (dev) dev.ports = data.ports;
                    renderDevices();
                }
            } catch (e) { clearInterval(poll); }
        }, 2000);
    }

    function showPorts(ip) {
        const dev = currentDevices.find(d => d.ip === ip);
        if (!dev) return;
        document.getElementById("modal-title").textContent = `Ports â€” ${ip} (${dev.hostname || "unknown"})`;
        const ports = dev.ports || [];
        let html;
        if (ports.length === 0) {
            html = "<p>No ports scanned yet.</p>";
        } else {
            const openPorts = ports.filter(p => p.state === "open");
            html = `<p>${openPorts.length} open port(s) found</p>
            <table><thead><tr><th>Port</th><th>Protocol</th><th>Service</th><th>Version</th><th>State</th></tr></thead><tbody>`;
            html += ports.map(p => `<tr>
                <td>${p.port}</td><td>${escapeHtml(p.protocol)}</td>
                <td>${escapeHtml(p.service)}</td><td>${escapeHtml(p.version || "-")}</td>
                <td>${escapeHtml(p.state)}</td>
            </tr>`).join("");
            html += `</tbody></table>`;
        }
        html += `<br><button class="scan-btn" onclick="closePortModal(); startPortScan('${escapeHtml(ip)}')">rescan</button>`;
        document.getElementById("modal-body").innerHTML = html;
        document.getElementById("port-modal").classList.add("show");
    }

    function closePortModal() {
        document.getElementById("port-modal").classList.remove("show");
    }

    document.getElementById("port-modal").addEventListener("click", e => {
        if (e.target === e.currentTarget) closePortModal();
    });

    // --- Bandwidth ---
    function initBandwidth() {
        if (chartInitialized) { fetchBandwidth(); return; }
        chartInitialized = true;
        const script = document.createElement("script");
        script.src = "https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js";
        script.onload = () => {
            const ctx = document.getElementById("bw-chart").getContext("2d");
            bwChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        { label: "RX", data: [], borderColor: "#00cc66", backgroundColor: "rgba(0,204,102,0.05)", fill: true, tension: 0.2, pointRadius: 0, borderWidth: 1.5 },
                        { label: "TX", data: [], borderColor: "#0088cc", backgroundColor: "rgba(0,136,204,0.05)", fill: true, tension: 0.2, pointRadius: 0, borderWidth: 1.5 }
                    ]
                },
                options: {
                    responsive: true,
                    animation: false,
                    interaction: { intersect: false, mode: "index" },
                    scales: {
                        x: { ticks: { color: "#333", maxTicksLimit: 10, font: { family: "Consolas, monospace", size: 10 } }, grid: { color: "#1a1a1a" } },
                        y: {
                            ticks: {
                                color: "#333",
                                callback: v => formatBytes(v),
                                font: { family: "Consolas, monospace", size: 10 }
                            },
                            grid: { color: "#1a1a1a" }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: "#555", font: { family: "Consolas, monospace", size: 11 } } },
                        tooltip: {
                            callbacks: { label: ctx => ctx.dataset.label + ": " + formatBytes(ctx.raw) }
                        }
                    }
                }
            });
            fetchBandwidth();
            if (bwInterval) clearInterval(bwInterval);
            bwInterval = setInterval(fetchBandwidth, 5000);
        };
        document.head.appendChild(script);
    }

    document.querySelectorAll(".time-btn").forEach(btn => {
        btn.addEventListener("click", () => {
            document.querySelectorAll(".time-btn").forEach(b => b.classList.remove("active"));
            btn.classList.add("active");
            bwMinutes = parseInt(btn.dataset.minutes);
            fetchBandwidth();
        });
    });

    async function fetchBandwidth() {
        try {
            const resp = await fetch(`/api/bandwidth?minutes=${bwMinutes}`);
            const data = await resp.json();
            if (data.current) {
                document.getElementById("bw-rx-val").textContent = formatBytes(data.current.rx_bytes_sec);
                document.getElementById("bw-tx-val").textContent = formatBytes(data.current.tx_bytes_sec);
            }
            if (bwChart && data.history) {
                bwChart.data.labels = data.history.map(s => {
                    const d = new Date(s.timestamp);
                    return d.toLocaleTimeString();
                });
                bwChart.data.datasets[0].data = data.history.map(s => s.rx_bytes_sec);
                bwChart.data.datasets[1].data = data.history.map(s => s.tx_bytes_sec);
                bwChart.update();
            }
        } catch (e) { console.error("Bandwidth fetch error:", e); }
    }

    // --- Network Graph ---
    function initGraph() {
        if (graphInitialized) { fetchTopology(); return; }
        graphInitialized = true;
        const script = document.createElement("script");
        script.src = "https://cdn.jsdelivr.net/npm/vis-network@9/dist/vis-network.min.js";
        script.onload = () => {
            const container = document.getElementById("network-graph");
            const data = { nodes: new vis.DataSet(), edges: new vis.DataSet() };
            const options = {
                physics: { stabilization: { iterations: 100 }, barnesHut: { gravitationalConstant: -3000 } },
                groups: {
                    router: { shape: "diamond", color: { background: "#cc8800", border: "#996600" }, size: 30, font: { color: "#888", size: 11, face: "Consolas, monospace" } },
                    online: { shape: "dot", color: { background: "#00cc66", border: "#009944" }, size: 12, font: { color: "#666", size: 10, face: "Consolas, monospace" } },
                    offline: { shape: "dot", color: { background: "#cc3333", border: "#991111" }, size: 8, font: { color: "#333", size: 10, face: "Consolas, monospace" }, opacity: 0.4 }
                },
                edges: { color: { color: "#1a1a1a", highlight: "#00cc66" }, width: 1 },
                interaction: { hover: true }
            };
            graphNetwork = new vis.Network(container, data, options);
            graphNetwork.on("stabilizationIterationsDone", () => {
                graphNetwork.setOptions({ physics: false });
            });
            fetchTopology();
            if (graphInterval) clearInterval(graphInterval);
            graphInterval = setInterval(fetchTopology, 10000);
        };
        document.head.appendChild(script);
    }

    async function fetchTopology() {
        if (!graphNetwork) return;
        try {
            const resp = await fetch("/api/topology");
            const data = await resp.json();
            const nodeDS = graphNetwork.body.data.nodes;
            const edgeDS = graphNetwork.body.data.edges;

            // Preserve positions of existing nodes
            const positions = graphNetwork.getPositions();

            const newNodeIds = new Set(data.nodes.map(n => n.id));
            const newEdgeIds = new Set(data.edges.map(e => e.from + "-" + e.to));

            // Remove old nodes/edges
            nodeDS.getIds().forEach(id => { if (!newNodeIds.has(id)) nodeDS.remove(id); });
            edgeDS.getIds().forEach(id => { if (!newEdgeIds.has(id)) edgeDS.remove(id); });

            // Add/update nodes
            data.nodes.forEach(n => {
                const existing = nodeDS.get(n.id);
                const pos = positions[n.id];
                const node = { id: n.id, label: n.label, group: n.group };
                if (pos) { node.x = pos.x; node.y = pos.y; }
                if (existing) { nodeDS.update(node); }
                else { nodeDS.add(node); }
            });

            // Add new edges
            data.edges.forEach(e => {
                const eid = e.from + "-" + e.to;
                if (!edgeDS.get(eid)) {
                    edgeDS.add({ id: eid, from: e.from, to: e.to });
                }
            });
        } catch (e) { console.error("Topology fetch error:", e); }
    }

    // --- History ---
    async function loadHistory(reset) {
        if (reset) {
            historyOffset = 0;
            document.getElementById("timeline").innerHTML = "";
            await populateHistoryFilter();
        }
        const ip = document.getElementById("history-filter").value;
        try {
            const url = `/api/history?limit=${HISTORY_LIMIT}&offset=${historyOffset}` + (ip ? `&ip=${ip}` : "");
            const resp = await fetch(url);
            const data = await resp.json();
            const timeline = document.getElementById("timeline");

            data.events.forEach(ev => {
                const item = document.createElement("div");
                item.className = `timeline-item ${ev.event_type}`;
                const label = ev.event_type === "connected" ? "came online" : "went offline";
                item.innerHTML = `
                    <div class="ev-time">${formatTime(ev.timestamp)}</div>
                    <div class="ev-desc">
                        <span class="ev-ip">${escapeHtml(ev.ip)}</span>
                        ${ev.hostname ? "(" + escapeHtml(ev.hostname) + ")" : ""}
                        ${label}
                    </div>`;
                timeline.appendChild(item);
            });

            historyOffset += data.events.length;
            document.getElementById("load-more-btn").style.display =
                data.events.length < HISTORY_LIMIT ? "none" : "block";
        } catch (e) { console.error("History fetch error:", e); }
    }

    function loadMoreHistory() { loadHistory(false); }

    async function populateHistoryFilter() {
        const sel = document.getElementById("history-filter");
        const current = sel.value;
        sel.innerHTML = '<option value="">All devices</option>';
        currentDevices.forEach(d => {
            const opt = document.createElement("option");
            opt.value = d.ip;
            opt.textContent = d.ip + (d.hostname ? ` (${d.hostname})` : "");
            sel.appendChild(opt);
        });
        sel.value = current;
    }

    document.getElementById("history-filter").addEventListener("change", () => loadHistory(true));

    // --- Latency ---
    let latChart = null;
    let latSelectedIp = null;
    let latMinutes = 60;
    let latInterval = null;
    let latSortCol = "ip";
    let latSortAsc = true;
    let latSummaryCache = [];
    let latSparklines = {};  // ip -> array of last 20 rtt values

    function initLatency() {
        fetchLatencySummary();
        if (latInterval) clearInterval(latInterval);
        latInterval = setInterval(fetchLatencySummary, 10000);
        ensureLatChart();
    }

    function ensureLatChart() {
        if (latChart) return;
        // Chart.js may already be loaded by bandwidth tab
        if (typeof Chart !== "undefined") {
            createLatChart();
        } else {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js";
            script.onload = createLatChart;
            document.head.appendChild(script);
        }
    }

    function createLatChart() {
        if (latChart) return;
        const ctx = document.getElementById("lat-chart").getContext("2d");
        latChart = new Chart(ctx, {
            type: "line",
            data: {
                labels: [],
                datasets: [{
                    label: "RTT (ms)",
                    data: [],
                    borderColor: "#00cc66",
                    backgroundColor: "rgba(0,204,102,0.05)",
                    fill: true, tension: 0.2, pointRadius: 2,
                    pointBackgroundColor: [], borderWidth: 1.5
                }]
            },
            options: {
                responsive: true, animation: false,
                interaction: { intersect: false, mode: "index" },
                scales: {
                    x: {
                        ticks: { color: "#333", maxTicksLimit: 10, font: { family: "Consolas, monospace", size: 10 } },
                        grid: { color: "#1a1a1a" }
                    },
                    y: {
                        title: { display: true, text: "ms", color: "#444", font: { family: "Consolas, monospace", size: 10 } },
                        ticks: { color: "#333", font: { family: "Consolas, monospace", size: 10 } },
                        grid: { color: "#1a1a1a" },
                        beginAtZero: true
                    }
                },
                plugins: {
                    legend: { labels: { color: "#555", font: { family: "Consolas, monospace", size: 11 } } },
                    tooltip: { callbacks: { label: ctx => ctx.raw !== null ? ctx.raw.toFixed(1) + " ms" : "packet lost" } }
                }
            }
        });
    }

    async function fetchLatencySummary() {
        try {
            const resp = await fetch("/api/latency/summary");
            const data = await resp.json();
            latSummaryCache = data.targets || [];
            renderInternetHealth();
            renderLatDeviceTable();
            if (latSelectedIp) fetchLatencyDetail();
        } catch (e) { console.error("Latency summary error:", e); }
    }

    function rttClass(rtt, lossPct) {
        if (rtt === null || rtt === undefined || lossPct > 50) return "bad";
        if (rtt > 150 || lossPct > 10) return "bad";
        if (rtt > 50) return "warn";
        return "good";
    }

    function renderInternetHealth() {
        const externals = ["1.1.1.1", "8.8.8.8", "1.0.0.1"];
        externals.forEach(ip => {
            const box = document.getElementById("inet-" + ip);
            if (!box) return;
            const t = latSummaryCache.find(s => s.ip === ip);
            const ind = box.querySelector(".inet-indicator");
            const rttEl = box.querySelector(".inet-rtt");
            const lossEl = box.querySelector(".inet-loss");

            if (t && t.latest_rtt !== null) {
                const cls = rttClass(t.latest_rtt, t.loss_pct);
                rttEl.textContent = t.latest_rtt.toFixed(1) + " ms";
                rttEl.className = "inet-rtt" + (cls !== "good" ? " " + cls : "");
                ind.className = "inet-indicator " + cls;
            } else if (t) {
                rttEl.textContent = "timeout";
                rttEl.className = "inet-rtt bad";
                ind.className = "inet-indicator bad";
            } else {
                rttEl.textContent = "--";
                rttEl.className = "inet-rtt";
                ind.className = "inet-indicator";
            }
            if (t) {
                lossEl.textContent = t.loss_pct.toFixed(1) + "% loss";
                lossEl.className = "inet-loss" + (t.loss_pct > 0 ? " has-loss" : "");
            }
        });
    }

    function renderLatDeviceTable() {
        const tbody = document.getElementById("lat-device-table");
        // Filter to LAN devices only
        let devices = latSummaryCache.filter(s => !s.is_external);

        // Sort
        devices = [...devices].sort((a, b) => {
            let va = a[latSortCol], vb = b[latSortCol];
            if (va == null) va = latSortCol === "ip" ? "" : 99999;
            if (vb == null) vb = latSortCol === "ip" ? "" : 99999;
            let cmp;
            if (latSortCol === "ip") {
                cmp = compareIP(String(va), String(vb));
            } else if (typeof va === "number") {
                cmp = va - vb;
            } else {
                cmp = String(va).localeCompare(String(vb));
            }
            return latSortAsc ? cmp : -cmp;
        });

        // Look up hostnames from currentDevices
        const hostMap = {};
        currentDevices.forEach(d => { hostMap[d.ip] = d.hostname || ""; });

        tbody.innerHTML = devices.map(d => {
            const cls = rttClass(d.latest_rtt, d.loss_pct);
            const rttStr = d.latest_rtt !== null ? d.latest_rtt.toFixed(1) : "--";
            const hostname = hostMap[d.ip] || "-";
            const selected = d.ip === latSelectedIp ? " selected" : "";

            // Sparkline from history cache
            const sparks = latSparklines[d.ip] || [];
            let sparkHtml = "";
            if (sparks.length > 0) {
                const maxRtt = Math.max(...sparks.filter(v => v !== null).map(Number), 1);
                sparkHtml = '<span class="lat-sparkline">' + sparks.map(v => {
                    if (v === null) return '<span class="lat-spark-bar loss" style="height:18px"></span>';
                    const h = Math.max(1, Math.round((v / maxRtt) * 18));
                    return `<span class="lat-spark-bar" style="height:${h}px"></span>`;
                }).join("") + '</span>';
            }

            return `<tr class="${selected}" onclick="selectLatDevice('${escapeHtml(d.ip)}')">
                <td>${escapeHtml(d.ip)}</td>
                <td>${escapeHtml(hostname)}</td>
                <td class="lat-rtt-${cls}">${rttStr}</td>
                <td class="${d.loss_pct > 0 ? 'lat-rtt-bad' : ''}">${d.loss_pct.toFixed(1)}%</td>
                <td>${sparkHtml}</td>
            </tr>`;
        }).join("");

        // Update sort arrows
        document.querySelectorAll(".lat-table th[data-latcol]").forEach(th => {
            const arrow = th.querySelector(".arrow");
            arrow.textContent = th.dataset.latcol === latSortCol ? (latSortAsc ? "\u25B2" : "\u25BC") : "";
        });
    }

    document.querySelectorAll(".lat-table th[data-latcol]").forEach(th => {
        th.addEventListener("click", () => {
            if (latSortCol === th.dataset.latcol) { latSortAsc = !latSortAsc; }
            else { latSortCol = th.dataset.latcol; latSortAsc = true; }
            renderLatDeviceTable();
        });
    });

    function selectLatDevice(ip) {
        latSelectedIp = ip;
        document.getElementById("lat-detail-ip").textContent = ip;
        renderLatDeviceTable();
        fetchLatencyDetail();
    }

    document.querySelectorAll(".lat-time-btn").forEach(btn => {
        btn.addEventListener("click", () => {
            document.querySelectorAll(".lat-time-btn").forEach(b => b.classList.remove("active"));
            btn.classList.add("active");
            latMinutes = parseInt(btn.dataset.latmin);
            if (latSelectedIp) fetchLatencyDetail();
        });
    });

    async function fetchLatencyDetail() {
        if (!latSelectedIp || !latChart) return;
        try {
            const resp = await fetch(`/api/latency?ip=${latSelectedIp}&minutes=${latMinutes}`);
            const data = await resp.json();
            const history = data.history || [];

            // Update sparkline cache (last 20 readings)
            const rttVals = history.slice(-20).map(s => s.rtt_ms);
            latSparklines[latSelectedIp] = rttVals;

            latChart.data.labels = history.map(s => new Date(s.timestamp).toLocaleTimeString());
            const rttData = history.map(s => s.rtt_ms);
            latChart.data.datasets[0].data = rttData;

            // Color points: red for loss, green for ok
            latChart.data.datasets[0].pointBackgroundColor = rttData.map(v =>
                v === null ? "#cc3333" : "#00cc66"
            );
            // Show lost packets as 0 on chart so they appear on x-axis
            latChart.data.datasets[0].data = rttData.map(v => v === null ? 0 : v);
            // Use spanGaps to connect across nulls
            latChart.data.datasets[0].spanGaps = true;

            latChart.update();
        } catch (e) { console.error("Latency detail error:", e); }
    }

    // --- Init ---
    fetchDevices();
    setInterval(fetchDevices, 10000);
    </script>
</body>
</html>
